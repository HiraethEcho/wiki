---
title: "由于担心历史记录变多占用本地存储空间所做的努力探索 - 每日闲聊"
source: "https://forum-zh.obsidian.md/t/topic/45752/4"
date: 2025-06-04
description: "讨论 Obsidian 用法与知识管理的地方"
dg-publish: true
---
缘起：

自接触 GitHub，看到许多几百几千的历史记录时，我便开始思考这个问题。那些数百前的提交几乎无人查看，却又动弹不得，都推了吧虽然自己确实也用不到了，对其他人又不太友好。可看其他人，又好像没人在乎这个问题似的……这一度让我非常难受。

好在经过不懈努力，最近想出了或许能成的办法。

在开始之前，我们的本地仓库有着全部的历史记录和全部的文件，同时远程仓库也推上去了，和本地一模一样。

这时，删除本地.git 文件夹， `rmdir /s /q ".git"`  
从远程克隆最新一次提交的裸仓库，改名为.git， `git clone --depth 1 --bare <repo> .git`  
并将设置中是否为裸仓库改为否。 `git config core.bare false`  
嗒，硬重置一下。 `git reset --hard HEAD`

这样，本地仓库就又联系起来了，并且只保留最新一次提交记录。

由于哈希值相同，之后虽然要硬推，远程仓库依然可以接着新增提交，而不会被推平。后续本地积累多了，就重复以上步骤，再次回到只有一个提交记录的状态。

顺便记录之前失败的尝试：

之前尝试复制主分支最新的树对象，作为首个提交创建新分支 `git commit-tree` ，新分支写得多了，就压缩合并 `merge --squash` 到主分支，删除新分支，然后重复以上步骤。

失败的根本原因是上述操作无法进行在本地新分支和远程主分支。如果始终要在本地存一个主分支，哪怕只是裸仓库，.git 文件夹还是一样大，还是占了这份空间。

另，由于强行中断历史记录，合并到主分支时，新增和修改的文件都能同步，但删除的不行。如果有人想复刻上述行为，记得合并前检查分支间差异，用程序删除主分支对应文件。

免责声明：

Git 的存储机制还是非常高效的，占用最多存储空间的大多仍是文件本身。此外，Git 的提交只是底层对象的引用，当你创建一个新分支，看到里面有主分支所有的历史记录，这并不意味着历史记录被复制了一份，占了双倍空间。只有当你提交新的内容，才会继续增加存储。

## 评论

[PlayerMiller](https://forum-zh.obsidian.md/u/PlayerMiller)

之前的内容聚焦于提交本身，这可能让人觉得如果提交被清除了，历史记录也就无法找回了。

但事实上，使用 `git reflog` 可以查看到所有的历史操作。

比如，现在仓库有 2 个提交：

```bash
3fa8c8f 12:32_0530 (HEAD -> main)
  65b2ace Add files via upload
```

现在我们使用 `git reset --hard` 将提交和工作区文件都回退到 65b2ace 的位置，而且也不记得之前的哈希值了。

这时，使用 `git log` 是看不到提交了。而 `git reflog` 的结果如下：

```
+ 65b2ace (HEAD -> main) HEAD@{0} reset: moving to 65b2ace
  3fa8c8f HEAD@{1} commit: 12:32_0530
  65b2ace HEAD@{2} commit: Add files via upload
```

这时我们又找到了之前提交的哈希值，然后再使用 `git reset --hard 3fa8c8f` 就撤销回退了。

不过既然还是能查询到之前的提交，说不定.git 的历史记录比我想象的还要难清除……
